### TCP详解

#### TCP Connection：

客户端与服务器之间数据的发送和返回的过程当中需要创建一个叫TCP connection的东西；

由于TCP不存在连接的概念，只存在请求和响应，请求和响应都是数据包，它们之间都是经过由TCP创建的一个从客户端发起，服务器接收的类似连接的通道，这个连接可以一直保持，http请求是在这个连接的基础上发送的；

在一个TCP连接上是可以发送多个http请求的，不同的版本这个模式不一样。

在HTTP/1.0中这个TCP连接是在http请求创建的时候同步创建的，http请求发送到服务器端，服务器端响应了之后，这个TCP连接就关闭了；

HTTP/1.1中可以以某种方式声明这个连接一直保持，一个请求传输完之后，另一个请求可以接着传输。这样的好处是：在创建一个TCP连接的过程中需要“三次握手”的消耗，“三次握手”代表有三次网络传输。

如果TCP连接保持，第二个请求发送就没有这“三次握手”的消耗。HTTP/2中同一个TCP连接里还可以并发地传输http请求。

#### TCP报文简介：

![64380cd7912397ddb480a4110c5c4ab2d1a28709](../image\64380cd7912397ddb480a4110c5c4ab2d1a28709.jpeg)

- 序号（seq）seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。
- **确认号**ack序号，，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1
- **标志位**
  - **SYN**：发起一个新连接
  - **FIN**：释放一个连接
  - **ACK**：确认序号有效
  - **URG**：紧急指针（urgent pointer）有效
  - **PSH**：接收方应该尽快将这个报文交给应用层
  - **RST**：重置连接

#### TCP三次握手详解



![d8f9d72a6059252d20d93b0a6645fb3e59b5b9d2](../image\d8f9d72a6059252d20d93b0a6645fb3e59b5b9d2.jpeg)

1. 客户端向服务端发送TCP报文

   - 标志位为SYN(发起连接请求)
   - seq(序号) = x  一般为1
   - 随后客户端进入SYN-SENT状态

2. 服务端接受TCP报文后，结束LISTEN状态，并返回一段TCP报文、表示服务器能正常接受客户端发送的数据，并同意客户端的请求

   - 标志位为SYN(发起链接请求)、ACK（确认序列号有效）  
   - seq(序号) = y
   - 确认号ack(确认号) = x + 1 ，表示收到客户端的需要seq并将值+1 作为自己的确认序号ack的值，服务器进入SYN-RCVD状态

3. 客户端接受Tcp报文后，结束SYN-SEND状态，并发送一段TCP报文、表示客户端到服务端的通信是正确的，

   - 标志位为SYN(发起链接请求)、ACK（确认序列号有效）
   - seq(序号) = x + 1 表示收到服务器的确认序号
   -  确认号ack(确认号) = y + 1  表示收到服务器的序号，并将其加1作为自己的确认序号
   - 客户端进入ESTABLISHED阶段
   - 服务器收到来自客户端的“确认收到服务器数据”的TCP报文之后，明确了从服务器到客户端的数据传输是正常的。结束SYN-RCVD阶段，进入ESTABLISHED阶段。

   ##### 为什么要进行三次握手：

   为了保证服务端能收接受到客户端的信息 并能做出正确的应答而进行前两次(第一次和第二次)握手，为了保证客户端能够接收到服务端的信息 并能做出正确的应答而进行后两次(第二次和第三次)握手。

   第一次：（服务端）能正确接受（客户端）消息，

   第二次：（客户端）能确认可以接收（服务端）消息、能确认（客户端）发送的消息（服务端）能够接收成功

   第三次：（服务端）能确认（服务端）发送的消息（客户端）能够接收成功

#### TCP四次握手详解：



![48540923dd54564e5260495ce0006487d0584fb6](../image\48540923dd54564e5260495ce0006487d0584fb6.jpeg)

1. 首先客户端想要释放链接，想服务端发送一段TCP报文：
   - 标志位FIN（表示请求释放链接）
   - 序号为seq = u
   - 随后客户端进入FIN-WAIT-1阶段，即半关闭阶段。并且停止在客户端到服务器端方向上发送数据，但是客户端仍然能接收从服务器端传输过来的数据。
2. 客户端接收到报文后，确认了客户端想要释放链接的请求服务端进屋CLOSE-WAIT状态，并向客户端发送了一端报文
   - 标志位为ACK（确认）
   - 序号seq = v
   - 确认序号ack = u + 1
   - 随后服务器端开始准备释放服务器端到客户端方向上的连接。
   - 客户端收到从服务器端发出的TCP报文之后，确认了服务器收到了客户端发出的释放连接请求，随后客户端结束FIN-WAIT-1阶段，进入FIN-WAIT-2阶段
   - 此时仍然可以进行数据传输
3. 服务端做好释放连接的准备后，再次向客户端发出一段TCP报文：
   - 标志位为FIN(释放链接) ACK（确认）
   - 序号为seq = w
   - 确认序号ack = u + 1
   - 服务器端结束CLOSE-WAIT阶段，进入LAST-ACK阶段。并且停止在服务器端到客户端的方向上发送数据，但是服务器端仍然能够接收从客户端传输过来的数据。
   - 客户端收到请求后结束FIN-WAIT-2阶段，进入TIME-WAIT阶段
4. 客户端向服务器端发送一段报文，其中：
   - 标志位为ACK
   - 序号为 seq = u+1 （将第三次请求的ack作为其序列号）
   - 确认号为Ack=w+1；
   - 服务端接收到请求后关闭链接

#### 半包和黏包问题

- **黏包**：TCP协议是网络通信协议中十分重要的协议，相比于UDP协议来说，它是一个可靠的传输协议，并且是一个面向数据流的协议；所谓面向数据流，其实是指数据传输是以流式的方式传输，这些传输的数据就像一条河里的水，他们之间是没有缝隙的，也就是说TCP协议传输的数据是无边界的，并没有包的概念；TCP是流传输（水管），UDP是包传输（水桶）
  - **发送端黏包**：采用TCP协议传输数据的客户端与服务器经常是保持一个长连接的状态（一次连接发一次数据不存在粘包），双方在连接不断开的情况下，可以一直传输数据；但当发送的数据包过于的小时，那么TCP协议默认的会启用Nagle算法，将这些较小的数据包进行合并发送（缓冲区数据发送是一个堆压的过程）；这个合并过程就是在发送缓冲区中进行的，也就是说数据发送出来它已经是粘包的状态了
  - **接受端黏包**：接收方采用TCP协议接收数据时的过程是这样的：数据到底接收方，从网络模型的下方传递至传输层，传输层的TCP协议处理是将其放置接收缓冲区，然后由应用层来主动获取（C语言用recv、read等函数）；这时会出现一个问题，就是我们在程序中调用的读取数据函数不能及时的把缓冲区中的数据拿出来，而下一个数据又到来并有一部分放入的缓冲区末尾，等我们读取数据时就是一个粘包；（放数据的速度 > 应用层拿数据速度）
- **半包**：可能是IP分片传输导致的，也可能是传输过程中丢失部分包导致出现的半包，还有可能就是一个包可能被分成了两次传输，在取数据的时候，先取到了一部分（还可能与接收的缓冲区大小有关系），总之就是一个数据包被分成了多次接收。
- **发送方黏包问题解决**
  - 发送产生是因为Nagle算法合并小数据包，那么可以禁用掉该算法；
  - TCP提供了强制数据立即传送的操作指令push，当填入数据后调用操作指令就可以立即将数据发送，而不必等待发送缓冲区填充自动发送；
- **接受方黏包问题解决**
  - 解析数据包头部信息，根据长度来接收；
  - 自定义数据格式：在数据中放入开始、结束标识；解析时根据格式抓取数据，缺点是数据内不能含有开始或结束标识；
  - 短连接传输，建立一次连接只传输一次数据就关闭；（不推荐）

#### OSI七层模型和Tcp/ip四层模型

![1629935-20190412155007282-2076867106](../\image\1629935-20190412155007282-2076867106.png)

#### 相关问题

1. 为什么握手需要三次，而挥手需要4次？
   - 是因为第二次握手的过程中，他的报文是SYN和ACK一起发送的，而挥手时是分别发送的，因为在分手时，还有一些必要数据要处理，并不能一起发送
2. 为什么客户端需要等待2MSL
   - **MSL**指的是Maximum Segment Lifetime：一段TCP报文在传输过程中的最大生命周期
   - 如果客户端在2MSL内，再次收到了来自服务器端的FIN报文，说明服务器端由于各种原因没有接收到客户端发出的ACK确认报文。客户端再次向服务器端发出ACK确认报文，计时器重置，重新开始2MSL的计时；否则客户端在2MSL内没有再次收到来自服务器端的FIN报文，说明服务器端正常接收了ACK确认报文，客户端可以进入CLOSED阶段，完成“四次挥手”。







