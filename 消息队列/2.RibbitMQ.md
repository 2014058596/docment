#### RabbitMq简介

- RabbitMQ是基于AMQP协议，采用Erlang开发的消息队列

#### 工作模型

- 由于RabbitMQ实现了AMQP协议，所以RabbitMQ的工作模型也是基于AMQP

![20201222113058](../\image\20201222113058.png)

- **元件**
  - **Broker（节点）**
    - 部署RabbitMQ的节点
  - **Connection（连接）**
    - 无论是生产者发送消息，还是消费者接受消息，都必须要跟Broker建立一个连接，这个连接是一个长连接
  - **Channel（信道）**
    - 为了避免创建和释放TCP长连接，而引入的概念，他是一个虚拟的连接，可以在TCP长连接中去释放和创建Channel，不同的Channel是相互隔离的，每个Channel都有自己的编号，每个客户端都有各自的TCP连接，Channel是RabbitMQ原生API里面的最重要的编程接口，也就是我们定义交换机、队列、绑定关系、发送消息、接受消息都是Channel的方法。
  - **Queue(队列)**
    - 用来存储消息，实际上RabbitMQ是用数据库来存储消息的，这个数据库跟RabbitMQ一样是用Erlang开发的，名字叫Mnesia。
  - **Consumer（消费者）**
    - Pull模式，消息存放在服务端，只有消费者主动获取才能拿到消息，实时性低，但是可以根据自己的消费能力去决定获取消息的频率
    - 只要生产者发送消息到服务器，就马上推送，实时性高，如果消费不过来就有可能造成消息挤压
    - 由于队列有FIFO的特性，只有确定前一条消息被消费者确认接收后，Broker，才会把这条消息从数据库删除，在投递下一个消息
    - 消费者和队列多对多，但在生产环境建议一个消费者只处理一个队列的消息，提升消息处理能力，增加消费者
  - **binding key （绑定键）**
    - 接交换机和队列进行绑定时，需要明确一个绑定键
  - **routing key （路由键）**
    - 生成这发送消息时会携带一个key，这个key叫路由键
  - **Exchange（交换器）**
    - Exchange不会存储消息，他根据规则进行消息分发
    - Exchange和队列也是多对多的绑定关系
    - 交换器发送消息时，根据消息的路由键、交换机的路由规则、绑定键进行消息的分发
    - 交换器路由规则
      - **Direct** 一个队列和直连类型的交换机绑定，需要指定一个明确的绑定键，当生产者发送消息会携带的路由键和和某个队列的绑定键完全匹配时，才会通过交换机路由到这个队列上
      - **Topic** 一个队列和主题类型的交换机绑定，生产者发送消息需携带的路由键，支持通配符（#0或多个单词 *代表一个单词 .代表分割）具体规则建议详细学习
      - **Fanout** 一个队列和广播类型的交换机绑定时，不需要指定绑定键，生产者也不需要携带路由键，所有与该交换机绑定的路由键都会收到相同的副本消息
      - **Headers（不常用）** 交换机时通过Headers头部来将消息映射到队列的，有点像HTTP的Headers，Hash结构中要求携带一个键“x-match”，这个键的Value可以是any或者all，这代表消息携带的Hash是需要全部匹配(all)，还是仅匹配一个键(any)就可以了。相比直连交换机，首部交换机的优势是匹配的规则不被限定为字符串(string)而是Object类型。
        - any: 只要在发布消息时携带的有一对键值对headers满足队列定义的多个参数arguments的其中一个就能匹配上，注意这里是键值对的完全匹配，只匹配到键了，值却不一样是不行的；
        - all：在发布消息时携带的所有Entry必须和绑定在队列上的所有Entry完全匹配
  - **Vhost（虚拟机）**
    - 他的作用类似于编程语言中的namespace 不同的Vhost可以有同名的Exchange和Queue,我们可以为不同的业务系统创建他们自己专属的Vhost

#### RabbitMQ进阶知识

- 队列TTL
  - x-message-ttl 所有队列中的消息超过时间未被消费时，都会过期
- 消息TTL
  - 消息属性中设置expiration
- 当同时设定了两个过期策略，最小的过期时间生效

##### 死信队列

- 消息过期如果没有任何配置，是会直接丢弃，我们可以通过配置让这样的消息变成死信，在别的队列存储
- **死信交换机DLX** 普通交换机
- **死信队列DLQ** 普通队列
- 死信队列流程图
  - ![微信截图_20201223141839](..\image\微信截图_20201223141839.png)
- 死信队列代码
  - ![微信截图_20201223142007](..\image\微信截图_20201223142007.png)
- 死信队列缺点
  - 如果用统一队列来设置TTL,在梯度非常多的情况下，比如1分钟，2分钟，5分钟，需要创建很多交换机和队列来路由消息
  - 如果设置单独的消息的TTL，可能会造成队列的消息阻塞，前一条没有出队列，（第一条30Min,第二条10min,即使第二条应该投递了，但由于第一条消息还未出队，所有无法投递）
  - 可能存在一定的时间误差
  - RabbitMQ3.5.7提供了一个插件来实现延时队列和功能
- 进入死信队列条件
  - 消息被消费者拒绝并且未设置重回队列
  - 队列达到最大长度，超过了Max length（消息数）或者Max length bytes(字节数)，最先入队的消息会被发送到DLX(死信队列交换机)

##### 流量控制

- 服务端流量控制
  - x-max-length： 队列中最大存储最大消息数，超过这个数量，对头的消息会被丢弃（队列中最老的消息）
  - x-max-length-bytes: 队列存储的最大消息容量（单位bytes），超过这个容量，对头的消息将会被丢弃
  - 内存控制：
    - 当MQ占用40%以上的内存时，MQ会主动排除一个内存警告并阻塞所有链接，可通过修改ribbitMQ.config的来调整内存阀值
  - 磁盘控制
    - 当磁盘低于可用空间或者低于指定的值时（默认50MB），触发流控措施
- 消费这限流
  - 默认情况下，如果不进行配置，RabbitMQ 会尽快的把队列中的消息发送到消费者，因为消费这在本地缓存的消息数量过多，可能会导致OOM或者影响其他进程的正常运行
  - 基于Consumer或者channel设置prefetch count的值，含义未Consumer端最大的unacked messages数目，当超过这个数值的消息未被确认，RabbitMQ会停止投递新的消息给该消费者

##### Rabbit可靠性

- 引起消息丢失的问题
  - 消息从生产者发送到Broker时，网络问题引起消息丢失
  - 消息从Exchange路由到Queue 消息丢失
  - 消息存在Queue ，当硬件发生故障怎么办
  - 消费者订阅消息，网络问题，导致消息丢失怎么办？怎么才能保证消息一定被消费了呢
- 消息发送到RabbitMQ服务器
  - confirm模式
    - **普通确认模式**：生产这调用channel.confirmSelect()方法讲信道设置为Confirm模式，一但消息发送到交换机后，RabbitMQ就会给生产者发送一个确认，也就是调用channel.waitForConfirms()返回True，这样生产者就知道消息被服务端接受了
    - **批量确认模式：** 批量确认比普通确认提高了效率，但发送多少条数据合适？比如我们100条消息确认一次，前面99都接收了，最后一条拒绝了，那么前面所有的消息都要重发
    - **异步确认模式：** 一边批量发送消息，一边确认，避免了批量确认模式的问题
  - Transaction事物模式
    - 使用方法自行百度
    - 如果事物在提交执行之前由于RabbitMQ异常崩溃或者其他原因抛出异常，这时候我们边可以将其补货，进而通过执行channel.txRollback（）进行回滚
    - 事物模式有一个缺点，他是阻塞的，一条消息没有发送完，不能发送下一条消息，他会榨干RabbitMQ服务器的性能，所以不建议使用
- 消息从Exchange路由到Queue 消息丢失
  - 可能是因为routingkey,或者队列不存在（生产环境不会有这样的问题）
  - 消息回发
  - 指定备份交换机
- 消息存储在队列中，当硬件发生故障怎么办？（不介绍如何持久化）
  - 开启队列持久化
  - 交换机持久化
  - 消息持久化
  - 集群
- 怎么才能保证消息一定被消费了
  - Ack机制
    - **自动ACK** 当消费者接收到消息的时候旧自动发送ACK
    - **手动ACK** 需要将autoAck 设置成false，然后手动的去ACK，然后RabbitMQ会显示的回复ACK后采取队列中移除消息
    - **AUTO** 方法没有发生异常，发送ack 如果方法抛出AmqpRejectAndDontRequeueException异常，消息不会回到队列，其他异常消息回到队列
  - 如果没有ACK的消息，消费者断开链接后，RabbitMQ会把这条消息发送给其他消费者，如果没有消费者，消费者重启后会重新消费这条消息，重复执行业务逻辑
  - 如果是消息无法处理或失败可以调用basicReject()、basicNack()拒绝  方法中的requeue的含义的是否重新入队列，如果重新进入队列中，可能会造成无线循环消费的情况
- 如果为了保证一直性，生产这必须要知道消费者有没有消费成功怎么办？
  - 消费者收到消息，处理完毕后，掉用生产者的API(破坏解耦)
  - 消费者收到消息，处理完毕后，发送响应信息给生产者
  - 生产者和消费者应该约定一个超时时间，如果这个超时时间，我们认为消费失败，如果失败了，消息肯定要重新发送
    - 谁来重发
      - 创建定时任务，每三十秒跑一次，找到业务表中这条业务的状态，如果失败，构建为MQ消息，重新发送
      - 设计一张单独的消息表，把所有发送的消息都保存，找出未回复的消息，重新发送（耗费性能，消耗数据库存储空间）
    - 相隔多久重发
      - 看业务有可能暂停的时间，例如重启等，一次的时间间隔未多久
    - 一共重发几次
      - 建议控制成3次
    - 重新发送消息不建议发送一摸一样的消息，建议增加一个字段标识

##### 消息幂等性

- 为了避免相同消息的重复消费,必须要采取一定的措施，RabbitMQ的服务端是没有这样的控制的，他并不知道对于你的业务来说什么才是重复的消息，所以这个只能在消费端控制
- 引起消息重复可能会有两个原因
  - 生产者向Rabbit发送消息，开启了Confirm模式，但未收到确认，消息重复投递
  - 消费者处理消息，还未发送ACK或其他原因，消息重复消费
- 如何设计幂等性
  - 可以为每个消息生成一个唯一id，通过数据库、redis等手段做重复控制

**RabbitMQ**顺序性

- 在RabbitMQ中，一个队列有多个消费者时，由于不同的消费者处理消息的速度是一样的，顺序无法保证，只有一个队列仅有一个消费者的情况才能保证消费顺序

**RabbitMQ集群**

- 集群有两种节点类型，一种是磁盘节点，一种是内存节点
  - **磁盘节点:** 将元数据（队列属性，交换机类型，绑定、vhost）放在磁盘中，默认为磁盘节点，一个集群至少需要一个磁盘节点来持久化数据
  - **内存节点：** 讲元数据放在内存中，内存节点也会讲磁盘节点的地址存在磁盘，如果是持久化的消息 ，会同时存在内存和磁盘，且建议应用连接内存节点，磁盘节点用来备份
- 集群类型
  - 普通集群模式
    - 不同节点直接只会相互同步元数据（交换机、队列、绑定关系、Vhost的定义），而不会同步消息
  - 镜像集群模式
    - 消息内容会在镜像节点间同步，可用性更高，不过系统的性能会降低，节点过多的情况下同步的代价比较大
    - 当节点中使用很多的内存节点，生产者通过负载均衡去访问RabbitMQ

#### 相关问题

- 消息队列的作用与使用场景
  - 解耦、异步处理
  - 当爬虫爬取到中标信息后，使用消息队列推送到其他服务CRM、微信公众号等
- Channel和Vhost的作用
  - Channel: 减少TCP的消耗
  - Vhost：提高利用率，实现资源隔离
- RabbitMQ的路由策略
  - 上文有
- 多个消费者监听一个队列，会重复消费吗
  - 轮训发送，不会出现重复消费
- 无法被路由的消息，去了哪里
  - 默认直接丢失，可以卑职备份交换机接口
- 消息在什么时候才会变成死信
  - 超过队列长度或容量，消息被拒绝并未设置重回队列
- RabbitMQ如何实现延时队列
  - 消息过期+死信队列
  - 延时队列插件
  - 数据库+定时任务，然后推送MQ
- 如何保证消息的顺序性
  - 一个队列只有一个消费者
- 如何保证RabbitMQ的高可用
  - keepalived+镜像集群
- 大量消息堆积怎么办
  - 清空重发
  - 增加消费者，或消费者开启多线程







