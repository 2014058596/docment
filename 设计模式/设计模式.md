### 设计模式

##### 分类

|          | 创建型模式                | 结构型模式                                                   | 行为型模式                                                   |
| -------- | ------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 类模式   | 工厂方法                  | (类）适配器                                                  | 模板方法<br />解释器                                         |
| 对象模式 | 单例 原型 抽象工厂 建造者 | 代理 (对象）<br />适配器 <br />桥接 <br />装饰 <br />外观 <br />享元 <br />组合 | 策略<br />命令<br />职责链<br />状态<br />观察者<br />中介者 <br />迭代器 <br />访问者 <br />备忘录 |

##### 设计模式7大原则

 	1. 开闭原则
     - 当需求发生改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以拓展模块的功能，使其满足新需求
 	2. 里氏替换原则
     - 子类可以拓展父类的功能，但不能修改父类原有的功能
 	3. 依赖倒置
      - 高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象；面向接口编程，不要面向实现编程
 	4. 迪米特法则
      - （最少知道原则）如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性
 	5. 单一职责
      - 一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分
 	6. 接口隔离
      - 尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法
 	7. 合成复用原则
     - 在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。

##### 设计模式

- [单例模式](http://c.biancheng.net/view/1338.html)
  - 一个类只有一个实例
- [原型模式](http://c.biancheng.net/view/1343.html)
  - 用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象
- [简单工厂模式](http://c.biancheng.net/view/8385.html)
  - 创建实例的方法通常为静态（static）方法
- [工厂方法模式](http://c.biancheng.net/view/1348.html)
  - 根据不同的工厂创建不同的对象
- [抽象工厂模式](http://c.biancheng.net/view/1351.html)
  - 抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，无须指定它们具体的类。（产品族概念（CPU和主板 ，不同产品华硕和联想 华硕和联想上层有顶级工厂））
- [建造者模式](https://www.runoob.com/design-pattern/builder-pattern.html)
  - 讲一个复杂对象分解为多个简单的对象一步一步构建完成
- [代理模式](http://c.biancheng.net/view/1359.html) 
  - 由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。
- [适配器模式](http://c.biancheng.net/view/1361.html)
  - 将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作
- [桥接模式](http://c.biancheng.net/view/1364.html)
  - 将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。（实现对应接口外，新建抽象类实现对应接口，使用组合关系调用方法）
- 装饰模式
- 外观模式
- 享元模式
- 组合模式
- [模板方法模式](http://c.biancheng.net/view/1376.html)
  - 定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤
- 策略模式
- 命令模式
- 责任链模式
- 状态模式
- 观察者模式
- 中介者模式
- 迭代器模式
- 访问者模式
- 备忘录模式
- 解释器模式

