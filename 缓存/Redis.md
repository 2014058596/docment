#### Redis

- **redis特性**
  - 数据存在内存中、访问速度更快、10W QPS
  - 支持丰富的数据类型
  - 支持多种编程语言
  - 功能丰富：持久化机制、内存淘汰策略、实物、发布订阅、lua脚本
  - 支持分布式集群
  
- Redis数据结构
  - String
  - Set
  - ZSet
  - list
  - hash
  
- Redis相关功能与实现

  - 可以使用list 实现消息队列
  - 发布订阅功能（不建议使用，哨兵模式的互相发现是通过此机制来实现的）
  - 事务
    - 特点
      - 按照进入队列的顺序执行
      - 不会受到其他客户端的请求影响
      - 事务不能嵌套，多个multi效果一样
    - 命令
      - **multi**（开启事务）
      - **exec** （执行事务）
      - **discard** （取消事务）
      - **watch** （监视）多个客户端更新变量时，会跟原值作比较，只有他没有被其他现成修改的情况下，才更新成新的值 客观锁的实现
    - 事务回滚的特点
      - exec之前发生错误，变量参数名错误等，命令会拒绝执行
      - exec之后发生错误，redis命令智慧因为错误的语法而失败，也就是说，从实用性的角度来说，失败的命令是由代码错误造成的，而这些错误应该在开发的过程中被发现，不会发生在生产环境所有不支持回滚
  - Lua脚本
    - 好处
      - 一次发送多个命令，减少网络开销
      - Redis会将脚本作为一个整体执行，不会被其他请求打断，保持原子性
      - 对于复杂的组合命令，我们可以放在文件中，实现复用
    - 坏处
      - 因为Redis的指令执行是单线程的，如果lua脚本超时，或陷入了死循环，会导致其他命令都进入等待状态，这显然是不行的。reids已经考虑到了，lua脚本有执行的默认超时时间为5秒钟

- Redis过期策略

  - **LRU** 最近至少使用，判断最近被使用的时间，最远的数据优先被删除
    - **Volatile-lru** 删除设置了超时属性的键，直到腾出足够内存为止，如果没有可删除的键对象，回退到noeviction（**推荐使用**）
    - **allkeys-lru**  不管数据有没有设置超时属性，都删除，直到腾出足够内存为止
  - **LFU** 最不常用使用，按照使用频率，如果一段时间没有使用，是可以进行减少频率的
    - **Volatile-lfu** 删除带有过期时间的键中最不常用的
    - **Allkeys-lfu** 删除所有键中最不常用的
  - **Random** 随机删除
    - **Volatile-random** 再有过期时间的键中随机选择
    - **Allkeys-random** 随机删除所有键，直到腾出足够的内存
  - **volatile-ttl** 根据建值对象的ttl属性，删除最近将要过期的数据，如果没有，回退到noeviction
  - **noeviction** 不会删除任何数据，拒绝所有写入操作，并返回客服端错误信息

- redis为什么这么快

  - 存内存结构（主要原因）
    - kv结构的内存数据库时间复杂度为O(1)
  - redis是单线程的
    - 没有创建线程和销毁线程的开销
    - 避免了上下文切换
    - 避免了线程之间带来的竞争
  - 多路复用机制（服务端数据返回客户端，需要从内核空间copy数据到用户空间，然后会写到socket,这个过程是非常耗时的，这个环境就是多线程的）

- Redis是单线程？

  - Redis处理客户端发来的数据操作请求（增删改查），只会使用一个线程去执行，因此叫做单线程。但是实际上，Redis在执行其他操作的时候，可能会开启多个进程或线程，比如说持久化。Redis执行BGSAVE指令，进行快照持久化时，就会fork出一个子进程，然后子进程去创建快照，完成持久化操作。
  - 6.0引入的io多路复用，但执行命令的操作依旧是单线程

- Redis持久化机制

  - **RDB ** redis默认的持久化方案，会生成一个dump.rdb文件，默认在安装目录下，redis重启会通过加载dump.rdb文件恢复数据

    ```
    save 900 1 #900秒内至少有一个key被修改
    save 300 10 #300秒内至少有10个key被修改
    save 60 10000 # 60秒至少有10000个key被修改
    ```

    - 可能会造成数据丢失，但是相比AOF速度更快

  - **AOF** 默认不开启，开启后，执行更改Redis数据的命令时，就会把命令写入到AOF文件中

    - AOF文件越来越大时，占用服务器的磁盘越大以及恢复的时间就越长，为了解决这个问题Redis新增了重写机制，当AOF文件的大小超过设定的阈值时，redis会压缩AOF，AOF压缩并不是对原文件进行整理，而是直接读取服务器现有的键值对，然后利用一条命令去代替之前记录这个键值对的多条命令，生成一个新文件，然后去替换原来的AOF文件
    - 相比RDB:  AOF每一次操作都会影响性能，AOF的文件也会更大 , 即使使用默认的同步频率每秒同步一次，Redis最多也就丢失1秒的数据而已





